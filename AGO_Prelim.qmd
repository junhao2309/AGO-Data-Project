---
title: "AGO_Prelim"
date: "9 Sep 2023"
date-modified: "`r Sys.Date()`"
number-sections: true
format: html
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---

# Setting Up

```{r}
library(dplyr)
library(readr)
library(ggplot2)
library(lubridate)
library(stringr)
library(crosstalk)
library(plotly)
```

```{r}
procurement_data <- read_csv("Data_file.csv")
```

```{r}
procurement_data[c(1,6999,7000), c(1,2,6)]
```

# Exploratory Data Analysis (EDA)

## Understanding the Dataset

-   Checking for Duplicate entries

```{r}
any(duplicated(procurement_data$`Procurement Code`))
```

Procurement Code does not have duplicated entries and has an assigned unique identifier to the transaction made.

::: panel-tabset
### Agency

This showcases the number of Government agencies and Statutory Boards within this dataset.

```{r}
unique(procurement_data$Agency)
```

There are a total of 15 agencies under this dataset.

### Procurement Description

This showcases how procurement purposes are being categorized.

```{r}
unique(procurement_data$`Procurement Description`)
```

There are a total of 20 categories of reasons for why procurement was made.

### Supplier

This showcases the catalogue of suppliers agencies may refer to for procurement

```{r}
unique(procurement_data$Supplier)
```

A total of 98 suppliers were paid for their services.
:::

## Setting the correct variable types

The code below shows the variable types for each column.

```{r}
glimpse(procurement_data)
```

Over here, we see that Date of Award and Awarded Amount are in character type and should be changed to date and integer respectively.

```{r}
clean_data <- procurement_data %>%
    mutate(`Date of Award (2017-2022)` = dmy(`Date of Award (2017-2022)`)) %>%
    mutate(`Awarded Amount` = as.numeric(gsub(",","", gsub("\\$","", `Awarded Amount`)))) %>%
    rename(Date = `Date of Award (2017-2022)`)

glimpse(clean_data)
```

For easier referencing, "Date of Award (2017-2022)" is changed to "Date".
As seen above, the respective columns have to changed accordingly.

## Data Cleaning

The first task is to ensure that the data is accurate and reliable.

Procurement procedures depend on the estimated value of the goods or services provided.

1.  Small value purchases (SVP)

    For goods or services with an estimated value of up to \$10,000.

2.  Invitation to Quote (ITQ)

    For goods or services with an estimated value of up to \$100,000.

3.  Invitation to Tender (ITT)

    For goods or services with an estimated value of above \$100,000.

### Checking Awarded Amount

Given the limits, we should ensure that the Procurement Type is accurate to the value attached to the procurement.

The code below shows that there are procurement done at below the value of \$10,000 but are not labelled as SVP.

```{r}
any(clean_data$`Awarded Amount` < 10000 & clean_data$`Procurement Type` == "SVP")
any(clean_data$`Awarded Amount` > 100000 & clean_data$`Procurement Type` == "ITT")
```

```{r}
for (i in 1:7000){
  if (clean_data$`Awarded Amount`[i] < 10000){
    if (clean_data$`Procurement Type`[i] != "SVP"){
      clean_data$`Procurement Type`[i] = "SVP"
    }
    if (clean_data$`Awarded Amount`[i] > 100000){
      if (clean_data$`Procurement Type`[i] != "ITT"){
        clean_data$`Procurement Type`[i] =="ITT"
      } 
    else {
      if (clean_data$`Procurement Type`[i] != "ITQ"){
        clean_data$`Procurement Type`[i] =="ITQ"
      }
    }    
    }
    
  }
}
```

```{r}
any(clean_data$`Awarded Amount` < 10000 & clean_data$`Procurement Type` == "SVP")
any(clean_data$`Awarded Amount` > 10000 & clean_data$`Awarded Amount` < 100000 & clean_data$`Procurement Type` == "ITQ")
any(clean_data$`Awarded Amount` > 100000 & clean_data$`Procurement Type` == "ITT")
```

### Procurement Code and Type

Through observation, we notice that the procurement code has the first three letters that indicate the procurement type.
Ensure that they are correctly identified and can be flagged accordingly to the agency handling such datasets.

```{r}
mismatched_indices <- which(str_sub(clean_data$`Procurement Code`, 1, 3) != clean_data$`Procurement Type`)
mismatched_indices
```

As we can see, there were 10 mismatched indices.

```{r}
clean_data[mismatched_indices, c(1,2,3,8)]
```

From the table above, all 10 were mislabeled as ITQ.
We can flag this to the team handling this dataset to keep watch.
This could be easily fixed through automated processes by automatically assigning the correct type and code based on amount declared or invoiced in.

Next, amend the dataframe accordingly to reflect the intended change.

```{r}
final_data <- clean_data %>%
  mutate(`Procurement Code` = ifelse(
    str_sub(`Procurement Code`, 1, 3) != `Procurement Type`,
    paste0(`Procurement Type`, str_sub(`Procurement Code`, 4)),
    `Procurement Code`
  ))
final_data[mismatched_indices,]
```

### Out of range data elements

The code below shows that there are at least two datasets outside the range of the suppose time period.

```{r}
which(any(final_data$Date < ymd("2017-01-01")),arr.ind = TRUE
)
which(any(final_data$Date > ymd("2022-12-31")), arr.ind = TRUE)
```

```{r}
date_min <- min(final_data$Date)
date_max <- max(final_data$Date)
which(final_data$Date == date_min)
which(final_data$Date == date_max)

final_data[c(1,7000),]


```

We can remove the two entries from the dataset.

```{r}
final <- final_data[-c(1,7000),]
```

```{r}
max(final$Date)
min(final$Date)
which(final$Date == max(final$Date))
final <- final[-6998,]
max(final$Date)
```

```{r, eval = FALSE}
readr::write_csv(final, "AGO_Cleaned_Data.csv")
```

Then we can just call this cleaned data from our folder.\

```{r}
clean_data <- read_csv("AGO_Cleaned_Data.csv")
```

## Visualisation

Here, we are visualising the Agency and the total sum spent per month just to have a sensing of the different agencies and size of expenditure.

```{r}
agency_grouped <- clean_data %>%
  group_by(`Procurement Type`, Agency, Month = floor_date(Date,"month")) %>%
  summarize(Total_Amount = sum(`Awarded Amount`), .groups = 'drop')
```

```{r}
library(DT)

datatable(agency_grouped)
```

### Plot

```{r}
library(plotly)
library(dplyr)

# Initialize an empty plot
plot_data <- plot_ly()

# Unique procurement types
procurement_types <- unique(agency_grouped$`Procurement Type`)

agencies <- unique(clean_data$Agency)

# Iteratively add traces for each combination of agency and procurement type
for (agency in agencies) {
    for (ptype in procurement_types) {
        plot_data <- add_trace(plot_data, 
                               data = filter(agency_grouped, Agency == agency, `Procurement Type` == ptype),
                               x = ~Month, 
                               y = ~Total_Amount, 
                               color = ~Agency,
                               line = list(shape = "spline"),
                               type = "scatter", mode = "lines+markers",
                               text = ~paste("Total Amount:", Total_Amount),
                               hoverinfo = "text+x",
                               name = paste(agency, ptype),
                               visible = agency == agencies[1] && ptype == procurement_types[1]  # Default visibility
        )
    }
}

# Set up the dropdown menu 
dropdown <- list()
counter <- 1
for (agency in agencies) {
    for (ptype in procurement_types) {
        visibility_vals <- rep(FALSE, length(agencies) * length(procurement_types))
        visibility_vals[counter] <- TRUE
        dropdown[[counter]] <- list(
            args = list("visible", visibility_vals),
            label = paste("Agency:", agency, "| Procurement Type:", ptype),
            method = "restyle"
        )
        counter <- counter + 1
    }
}

# Add dropdown to the layout and remove the legend
plot_data <- layout(plot_data, 
                    title = "Sum of Amount Awarded Over Time by Agency and Procurement Type",
                    xaxis = list(rangeslider = list(visible = TRUE)),
                    yaxis = list(title = "Total Amount"),
                    showlegend = FALSE,  # Hides the legend
                    updatemenus = list(
                        list(
                            y = 0.95,  # Adjust the position of dropdown
                            x = 1,
                            yanchor = "top",
                            xanchor = "left",
                            buttons = dropdown
                        )
                    ),
                    margin = list(l = 250, r = 50, b = 40, t = 40, pad = 4)
                    )
plot_data
```

```{r}
library(dplyr)

# Generate the summary table
summary_table <- clean_data %>%
  group_by(`Procurement Description`) %>%
  summarise(num_suppliers = n_distinct(Supplier))

print(summary_table)

```

# Claims made with the same value

Here

```{r}
# Find the index of duplicated values
duplicated_index <- which(duplicated(clean_data$`Awarded Amount`) | duplicated(clean_data$`Awarded Amount`, fromLast = TRUE))
list_of_duplicate_amounts <- clean_data[duplicated_index,]
```

```{r}
duplicated_index <- which(duplicated(list_of_duplicate_amounts[, c("Awarded Amount", "Agency", "Supplier")]) | 
                         duplicated(list_of_duplicate_amounts[, c("Awarded Amount", "Agency", "Supplier" )], fromLast = TRUE))

duplicate_amount <- list_of_duplicate_amounts[duplicated_index,]
```

From the above, we see entries that are duplicated for whether the amount is similar and whether the agency or suppliers that claims were made under are the same.
Due to the categorisation of the claims amount.
The value of an awarded amount split into two procurement claim can evade the ITT categorisation checks.These procurement claims should be highlighted as potential fraudulant activities.

# Claims made within the same day

```{r}
# Find the index of duplicated values
duplicated_index <- which(duplicated(clean_data$Date) | duplicated(clean_data$Date, fromLast = TRUE))
same_day_claims <- clean_data[duplicated_index,]
same_day_claims
```

```{r}
same_day_claims <- same_day_claims %>%
  arrange(Date)

same_day_procurement <- same_day_claims %>%
  group_by(Date) %>%
  filter(n() > 1) %>%
  group_by(Agency,Supplier, `Procurement Description`, .add = TRUE) %>%
  filter(n()> 1)

repeated_procurement <- rbind(duplicate_amount,same_day_procurement) %>%
  distinct(`S/N`, .keep_all = TRUE)

DT::datatable(repeated_procurement)
```

# Analysis of 5 agencies

```{r}
clean_data$Year <- as.numeric(format(clean_data$Date, "%Y"))
```

Once the dataset is set, we will create a shiny app to visualise the data.
Due to the various procurement types and agencies, having a central visualization tool that takes in user input would facilitate the process.

```{r}
agency_list <- c("National Commission for Space Exploration", 
                 "National Cybersecurity Task Force",
                 "National Institute of Scientific Advancement",
                 "Office of International Relations and Diplomatic Affairs",
                 "Office of Public Safety and Emergency Management")

NCSE <- clean_data %>%
  filter(Agency == "National Commission for Space Exploration")
NCTF <- clean_data %>%
  filter(Agency == "National Cybersecurity Task Force")
NISA <- clean_data %>%
  filter(Agency == "National Institute of Scientific Advancement")
OIRDA <- clean_data %>%
  filter(Agency == "Office of International Relations and Diplomatic Affairs")
OPSEM <- clean_data %>%
  filter(Agency == "Office of Public Safety and Emergency Management")
```

## Visualisation of aggregate expenditure by task

In all 5 agencies, I will be looking specifically on their spending on each unique procurement description.

::: panel-tabset
## National Commission for Space Exploration

```{r}
# Split the data into a list of dataframes based on the 'description' column
list_of_dfs <- split(NCSE, NCSE$`Procurement Description`)

# Aggregate awarded amount by year for each dataframe in the list
aggregated_data <- lapply(list_of_dfs, function(df) {
  aggregate(`Awarded Amount` ~ Year, data = df, sum)
})

# If you want each aggregated dataframe in the list as a separate dataframe:
list2env(aggregated_data, envir = .GlobalEnv)

```

```{r}
library(ggplot2)
library(gridExtra)

plots <- list() 
for (i in 1:20){
data <- as.data.frame(aggregated_data[[i]])
wrapped_title <- label_wrap_gen(width = 20)(names(aggregated_data)[i])
plot_graph <- ggplot(data, aes(x = Year, y = `Awarded Amount`)) +
    geom_line(aes(color = "blue")) +
    geom_point(color = "blue") +
    labs(title = wrapped_title) +
      theme_minimal()
    
plots[[i]] <- plot_graph
}


```

```{r}
grid.arrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], ncol = 2, nrow = 2)

```

```{r}
grid.arrange(plots[[5]], plots[[6]], plots[[7]], plots[[8]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[9]], plots[[10]], plots[[11]], plots[[12]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[13]], plots[[14]], plots[[15]], plots[[16]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[17]], plots[[18]], plots[[19]], plots[[20]], ncol = 2, nrow = 2)
```

## National Cybersecurity Task Force

```{r}
# Split the data into a list of dataframes based on the 'description' column
list_of_dfs <- split(NCTF, NCTF$`Procurement Description`)

# Aggregate awarded amount by year for each dataframe in the list
aggregated_data <- lapply(list_of_dfs, function(df) {
  aggregate(`Awarded Amount` ~ Year, data = df, sum)
})

# If you want each aggregated dataframe in the list as a separate dataframe:
list2env(aggregated_data, envir = .GlobalEnv)

```

```{r}
library(ggplot2)
library(gridExtra)

plots <- list() 
for (i in 1:20){
data <- as.data.frame(aggregated_data[[i]])
wrapped_title <- label_wrap_gen(width = 20)(names(aggregated_data)[i])
plot_graph <- ggplot(data, aes(x = Year, y = `Awarded Amount`)) +
    geom_line(aes(color = "blue")) +
    geom_point(color = "blue") +
    labs(title = wrapped_title) +
      theme_minimal()
    
plots[[i]] <- plot_graph
}


```

```{r}
grid.arrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], ncol = 2, nrow = 2)

```

```{r}
grid.arrange(plots[[5]], plots[[6]], plots[[7]], plots[[8]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[9]], plots[[10]], plots[[11]], plots[[12]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[13]], plots[[14]], plots[[15]], plots[[16]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[17]], plots[[18]], plots[[19]], plots[[20]], ncol = 2, nrow = 2)
```

## National Institute of Scientific Advancement

```{r}
# Split the data into a list of dataframes based on the 'description' column
list_of_dfs <- split(NISA, NISA$`Procurement Description`)

# Aggregate awarded amount by year for each dataframe in the list
aggregated_data <- lapply(list_of_dfs, function(df) {
  aggregate(`Awarded Amount` ~ Year, data = df, sum)
})

# If you want each aggregated dataframe in the list as a separate dataframe:
list2env(aggregated_data, envir = .GlobalEnv)

```

```{r}
library(ggplot2)
library(gridExtra)

plots <- list() 
for (i in 1:20){
data <- as.data.frame(aggregated_data[[i]])
wrapped_title <- label_wrap_gen(width = 20)(names(aggregated_data)[i])
plot_graph <- ggplot(data, aes(x = Year, y = `Awarded Amount`)) +
    geom_line(aes(color = "blue")) +
    geom_point(color = "blue") +
    labs(title = wrapped_title) +
      theme_minimal()
    
plots[[i]] <- plot_graph
}


```

```{r}
grid.arrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], ncol = 2, nrow = 2)

```

```{r}
grid.arrange(plots[[5]], plots[[6]], plots[[7]], plots[[8]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[9]], plots[[10]], plots[[11]], plots[[12]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[13]], plots[[14]], plots[[15]], plots[[16]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[17]], plots[[18]], plots[[19]], plots[[20]], ncol = 2, nrow = 2)
```

## Office of International Relations and Diplomatic Affairs

```{r}
# Split the data into a list of dataframes based on the 'description' column
list_of_dfs <- split(OIRDA, OIRDA$`Procurement Description`)

# Aggregate awarded amount by year for each dataframe in the list
aggregated_data <- lapply(list_of_dfs, function(df) {
  aggregate(`Awarded Amount` ~ Year, data = df, sum)
})

# If you want each aggregated dataframe in the list as a separate dataframe:
list2env(aggregated_data, envir = .GlobalEnv)

```

```{r}
library(ggplot2)
library(gridExtra)

plots <- list() 
for (i in 1:20){
data <- as.data.frame(aggregated_data[[i]])
wrapped_title <- label_wrap_gen(width = 20)(names(aggregated_data)[i])
plot_graph <- ggplot(data, aes(x = Year, y = `Awarded Amount`)) +
    geom_line(aes(color = "blue")) +
    geom_point(color = "blue") +
    labs(title = wrapped_title) +
      theme_minimal()
    
plots[[i]] <- plot_graph
}


```

```{r}
grid.arrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], ncol = 2, nrow = 2)

```

```{r}
grid.arrange(plots[[5]], plots[[6]], plots[[7]], plots[[8]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[9]], plots[[10]], plots[[11]], plots[[12]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[13]], plots[[14]], plots[[15]], plots[[16]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[17]], plots[[18]], plots[[19]], plots[[20]], ncol = 2, nrow = 2)
```

## Office of Public Safety and Emergency Management

```{r}
# Split the data into a list of dataframes based on the 'description' column
list_of_dfs <- split(OPSEM, OPSEM$`Procurement Description`)

# Aggregate awarded amount by year for each dataframe in the list
aggregated_data <- lapply(list_of_dfs, function(df) {
  aggregate(`Awarded Amount` ~ Year, data = df, sum)
})

# If you want each aggregated dataframe in the list as a separate dataframe:
list2env(aggregated_data, envir = .GlobalEnv)

```

```{r}
library(ggplot2)
library(gridExtra)

plots <- list() 
for (i in 1:20){
data <- as.data.frame(aggregated_data[[i]])
wrapped_title <- label_wrap_gen(width = 20)(names(aggregated_data)[i])
plot_graph <- ggplot(data, aes(x = Year, y = `Awarded Amount`)) +
    geom_line(aes(color = "blue")) +
    geom_point(color = "blue") +
    labs(title = wrapped_title) +
      theme_minimal()
    
plots[[i]] <- plot_graph
}


```

```{r}
grid.arrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], ncol = 2, nrow = 2)

```

```{r}
grid.arrange(plots[[5]], plots[[6]], plots[[7]], plots[[8]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[9]], plots[[10]], plots[[11]], plots[[12]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[13]], plots[[14]], plots[[15]], plots[[16]], ncol = 2, nrow = 2)
```

```{r}
grid.arrange(plots[[17]], plots[[18]], plots[[19]], plots[[20]], ncol = 2, nrow = 2)
```
:::

```{r}

```

```{r}
breaks <- c(0 ,10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000)
# Define levels
labels <- c("Level 0","Level 1", "Level 2", "Level 3", "Level 4", "Level 5", "Level 6", "Level 7", "Level 8", "Level 9")
# Assign levels based on Amount
NCSE_ITQ <- NCSE %>% 
  filter(`Procurement Type` == "ITQ")

NCSE_ITQ$Level <- cut(NCSE_ITQ$`Awarded Amount`, breaks = breaks, labels = labels, include.lowest = TRUE)
```

```{r}
ggplot(NCSE_ITQ, aes(x=Level)) +
  geom_bar(position="dodge") +
  labs(title="Number of Claims per Level", x="Level", y="Count") +
  theme_minimal() +
  theme(legend.position="none")
```

```{r}
breaks <- c(100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000, 1000000, 10000000)
labels <- c("Level 1", "Level 2", "Level 3", "Level 4", "Level 5", "Level 6", "Level 7", "Level 8", "Level 9", "Level 10")
# Assign levels based on Amount
NCSE_ITT <- NCSE %>% 
  filter(`Procurement Type` == "ITT")

NCSE_ITT$Level <- cut(NCSE_ITT$`Awarded Amount`, breaks = breaks, labels = labels, include.lowest = TRUE)
```

```{r}
ggplot(NCSE_ITT, aes(x=Level)) +
  geom_bar(position="dodge") +
  labs(title="Number of Claims per Level", x="Level", y="Count") +
  theme_minimal() +
  theme(legend.position="none")
```
